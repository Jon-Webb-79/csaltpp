<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csalt++: slt::DenseMatrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">csalt++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceslt.html">slt</a></li><li class="navelem"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classslt_1_1DenseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">slt::DenseMatrix&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A dense matrix implementation supporting float or double values.  
 <a href="classslt_1_1DenseMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for slt::DenseMatrix&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classslt_1_1DenseMatrix__inherit__graph.png" border="0" usemap="#aslt_1_1DenseMatrix_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aslt_1_1DenseMatrix_3_01T_01_4_inherit__map" id="aslt_1_1DenseMatrix_3_01T_01_4_inherit__map">
<area shape="rect" title="A dense matrix implementation supporting float or double values." alt="" coords="5,80,172,107"/>
<area shape="rect" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types." alt="" coords="9,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for slt::DenseMatrix&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classslt_1_1DenseMatrix__coll__graph.png" border="0" usemap="#aslt_1_1DenseMatrix_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aslt_1_1DenseMatrix_3_01T_01_4_coll__map" id="aslt_1_1DenseMatrix_3_01T_01_4_coll__map">
<area shape="rect" title="A dense matrix implementation supporting float or double values." alt="" coords="5,80,172,107"/>
<area shape="rect" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types." alt="" coords="9,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02b7df353b3562388432f1bbbb8bab54"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a02b7df353b3562388432f1bbbb8bab54">size</a> () const</td></tr>
<tr class="memdesc:a02b7df353b3562388432f1bbbb8bab54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the matrix.  <a href="classslt_1_1DenseMatrix.html#a02b7df353b3562388432f1bbbb8bab54">More...</a><br /></td></tr>
<tr class="separator:a02b7df353b3562388432f1bbbb8bab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529848163b44a2168460198adda171f7"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a529848163b44a2168460198adda171f7">data_ptr</a> () const</td></tr>
<tr class="memdesc:a529848163b44a2168460198adda171f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first value within the data array.  <a href="classslt_1_1DenseMatrix.html#a529848163b44a2168460198adda171f7">More...</a><br /></td></tr>
<tr class="separator:a529848163b44a2168460198adda171f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdc9d44da3d03b7941e9eb1eec36340"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a4cdc9d44da3d03b7941e9eb1eec36340">data_ptr</a> ()</td></tr>
<tr class="memdesc:a4cdc9d44da3d03b7941e9eb1eec36340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first value within the data array.  <a href="classslt_1_1DenseMatrix.html#a4cdc9d44da3d03b7941e9eb1eec36340">More...</a><br /></td></tr>
<tr class="separator:a4cdc9d44da3d03b7941e9eb1eec36340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631142d8a7cbb38a6e8210569e8605d4"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a631142d8a7cbb38a6e8210569e8605d4">init_ptr</a> () const</td></tr>
<tr class="memdesc:a631142d8a7cbb38a6e8210569e8605d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first value within the init array.  <a href="classslt_1_1DenseMatrix.html#a631142d8a7cbb38a6e8210569e8605d4">More...</a><br /></td></tr>
<tr class="separator:a631142d8a7cbb38a6e8210569e8605d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d3181181df8997b1f81135ba6fe1d2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a33d3181181df8997b1f81135ba6fe1d2">nonzero_count</a> () const</td></tr>
<tr class="memdesc:a33d3181181df8997b1f81135ba6fe1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of initialized elements in the matrix.  <a href="classslt_1_1DenseMatrix.html#a33d3181181df8997b1f81135ba6fe1d2">More...</a><br /></td></tr>
<tr class="separator:a33d3181181df8997b1f81135ba6fe1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb68f3c5f27bd69a67d1e1f7b51831e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#aefb68f3c5f27bd69a67d1e1f7b51831e">DenseMatrix</a> (std::size_t r, std::size_t c, T value)</td></tr>
<tr class="memdesc:aefb68f3c5f27bd69a67d1e1f7b51831e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix with given dimensions and fills it with a specified value.  <a href="classslt_1_1DenseMatrix.html#aefb68f3c5f27bd69a67d1e1f7b51831e">More...</a><br /></td></tr>
<tr class="separator:aefb68f3c5f27bd69a67d1e1f7b51831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b119a507ec3de68409be6404505239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a85b119a507ec3de68409be6404505239">DenseMatrix</a> (std::size_t r, std::size_t c)</td></tr>
<tr class="memdesc:a85b119a507ec3de68409be6404505239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix with given dimensions and zero-initializes all elements.  <a href="classslt_1_1DenseMatrix.html#a85b119a507ec3de68409be6404505239">More...</a><br /></td></tr>
<tr class="separator:a85b119a507ec3de68409be6404505239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b54af6e439372387f32809fdb354eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a04b54af6e439372387f32809fdb354eb">DenseMatrix</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vec)</td></tr>
<tr class="memdesc:a04b54af6e439372387f32809fdb354eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from a nested std::vector of values.  <a href="classslt_1_1DenseMatrix.html#a04b54af6e439372387f32809fdb354eb">More...</a><br /></td></tr>
<tr class="separator:a04b54af6e439372387f32809fdb354eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1527e4de225bc7b3537e3c4a1af474f3"><td class="memTemplParams" colspan="2">template&lt;std::size_t Rows, std::size_t Cols&gt; </td></tr>
<tr class="memitem:a1527e4de225bc7b3537e3c4a1af474f3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a1527e4de225bc7b3537e3c4a1af474f3">DenseMatrix</a> (const std::array&lt; std::array&lt; T, Cols &gt;, Rows &gt; &amp;arr)</td></tr>
<tr class="memdesc:a1527e4de225bc7b3537e3c4a1af474f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from a fixed-size std::array of std::array values.  <a href="classslt_1_1DenseMatrix.html#a1527e4de225bc7b3537e3c4a1af474f3">More...</a><br /></td></tr>
<tr class="separator:a1527e4de225bc7b3537e3c4a1af474f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9938ed4a846403bc6584ee47a9bd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a8cc9938ed4a846403bc6584ee47a9bd9">DenseMatrix</a> (std::initializer_list&lt; std::initializer_list&lt; T &gt;&gt; init_list)</td></tr>
<tr class="memdesc:a8cc9938ed4a846403bc6584ee47a9bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from an initializer list of initializer lists.  <a href="classslt_1_1DenseMatrix.html#a8cc9938ed4a846403bc6584ee47a9bd9">More...</a><br /></td></tr>
<tr class="separator:a8cc9938ed4a846403bc6584ee47a9bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf2b60ad5bd47d6dabaf714dd1f6727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#adcf2b60ad5bd47d6dabaf714dd1f6727">DenseMatrix</a> (const std::vector&lt; T &gt; &amp;flat_data, std::size_t r, std::size_t c)</td></tr>
<tr class="memdesc:adcf2b60ad5bd47d6dabaf714dd1f6727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from a flat data vector with explicit dimensions.  <a href="classslt_1_1DenseMatrix.html#adcf2b60ad5bd47d6dabaf714dd1f6727">More...</a><br /></td></tr>
<tr class="separator:adcf2b60ad5bd47d6dabaf714dd1f6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b3d24ccb26cc6fba021da75cdca42e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a48b3d24ccb26cc6fba021da75cdca42e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a48b3d24ccb26cc6fba021da75cdca42e">DenseMatrix</a> (const std::array&lt; T, N &gt; &amp;arr, std::size_t r, std::size_t c)</td></tr>
<tr class="memdesc:a48b3d24ccb26cc6fba021da75cdca42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix from a flat std::array with specified dimensions.  <a href="classslt_1_1DenseMatrix.html#a48b3d24ccb26cc6fba021da75cdca42e">More...</a><br /></td></tr>
<tr class="separator:a48b3d24ccb26cc6fba021da75cdca42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64fec350273642bd69b2500001c63be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ac64fec350273642bd69b2500001c63be">DenseMatrix</a> (const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ac64fec350273642bd69b2500001c63be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>.  <a href="classslt_1_1DenseMatrix.html#ac64fec350273642bd69b2500001c63be">More...</a><br /></td></tr>
<tr class="separator:ac64fec350273642bd69b2500001c63be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfda95ba96454680c4339e636195c58b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#acfda95ba96454680c4339e636195c58b">DenseMatrix</a> (<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:acfda95ba96454680c4339e636195c58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>.  <a href="classslt_1_1DenseMatrix.html#acfda95ba96454680c4339e636195c58b">More...</a><br /></td></tr>
<tr class="separator:acfda95ba96454680c4339e636195c58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4755d6afb58a6cb916b70a153f4aa7ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a4755d6afb58a6cb916b70a153f4aa7ef">DenseMatrix</a> (std::size_t n)</td></tr>
<tr class="memdesc:a4755d6afb58a6cb916b70a153f4aa7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a square identity matrix of size n x n.  <a href="classslt_1_1DenseMatrix.html#a4755d6afb58a6cb916b70a153f4aa7ef">More...</a><br /></td></tr>
<tr class="separator:a4755d6afb58a6cb916b70a153f4aa7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c081ccac829706e7b345faf2acf42d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a77c081ccac829706e7b345faf2acf42d">operator()</a> (std::size_t r, std::size_t c)</td></tr>
<tr class="memdesc:a77c081ccac829706e7b345faf2acf42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access or assign a value at the specified matrix index (r, c).  <a href="classslt_1_1DenseMatrix.html#a77c081ccac829706e7b345faf2acf42d">More...</a><br /></td></tr>
<tr class="separator:a77c081ccac829706e7b345faf2acf42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031fc322b994002ef9c2c10540a99603"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a031fc322b994002ef9c2c10540a99603">operator()</a> (std::size_t r, std::size_t c) const</td></tr>
<tr class="memdesc:a031fc322b994002ef9c2c10540a99603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to a matrix element at (r, c).  <a href="classslt_1_1DenseMatrix.html#a031fc322b994002ef9c2c10540a99603">More...</a><br /></td></tr>
<tr class="separator:a031fc322b994002ef9c2c10540a99603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f16ef2fe485bfeaff37e07be5cbb437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a4f16ef2fe485bfeaff37e07be5cbb437">operator=</a> (const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a4f16ef2fe485bfeaff37e07be5cbb437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>.  <a href="classslt_1_1DenseMatrix.html#a4f16ef2fe485bfeaff37e07be5cbb437">More...</a><br /></td></tr>
<tr class="separator:a4f16ef2fe485bfeaff37e07be5cbb437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edb94832d0cb9421cfe9e85b8d56b33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a2edb94832d0cb9421cfe9e85b8d56b33">operator=</a> (<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a2edb94832d0cb9421cfe9e85b8d56b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>.  <a href="classslt_1_1DenseMatrix.html#a2edb94832d0cb9421cfe9e85b8d56b33">More...</a><br /></td></tr>
<tr class="separator:a2edb94832d0cb9421cfe9e85b8d56b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bfb57f1f4c7f11110926bd3625834a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a01bfb57f1f4c7f11110926bd3625834a">operator+</a> (const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a01bfb57f1f4c7f11110926bd3625834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> objects element-wise.  <a href="classslt_1_1DenseMatrix.html#a01bfb57f1f4c7f11110926bd3625834a">More...</a><br /></td></tr>
<tr class="separator:a01bfb57f1f4c7f11110926bd3625834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76746086f9f6b50cd82d09b7d648b38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a76746086f9f6b50cd82d09b7d648b38e">operator+</a> (T scalar) const</td></tr>
<tr class="memdesc:a76746086f9f6b50cd82d09b7d648b38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scalar to all elements of the matrix.  <a href="classslt_1_1DenseMatrix.html#a76746086f9f6b50cd82d09b7d648b38e">More...</a><br /></td></tr>
<tr class="separator:a76746086f9f6b50cd82d09b7d648b38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a5482eb0dbba6aa16825fda6eac2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a64a5482eb0dbba6aa16825fda6eac2ac">operator-</a> (const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a64a5482eb0dbba6aa16825fda6eac2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise matrix subtraction.  <a href="classslt_1_1DenseMatrix.html#a64a5482eb0dbba6aa16825fda6eac2ac">More...</a><br /></td></tr>
<tr class="separator:a64a5482eb0dbba6aa16825fda6eac2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d52da76847341fc62f9101b961d98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a97d52da76847341fc62f9101b961d98d">operator-</a> (T scalar) const</td></tr>
<tr class="memdesc:a97d52da76847341fc62f9101b961d98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction from all elements of the matrix.  <a href="classslt_1_1DenseMatrix.html#a97d52da76847341fc62f9101b961d98d">More...</a><br /></td></tr>
<tr class="separator:a97d52da76847341fc62f9101b961d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b2210e92edcb57fb8d042e185571f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ab28b2210e92edcb57fb8d042e185571f">operator*</a> (const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:ab28b2210e92edcb57fb8d042e185571f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise matrix multiplication.  <a href="classslt_1_1DenseMatrix.html#ab28b2210e92edcb57fb8d042e185571f">More...</a><br /></td></tr>
<tr class="separator:ab28b2210e92edcb57fb8d042e185571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eea42d2bdb71d69270abed1daf55168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a5eea42d2bdb71d69270abed1daf55168">operator*</a> (T scalar) const</td></tr>
<tr class="memdesc:a5eea42d2bdb71d69270abed1daf55168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply all matrix elements by a scalar.  <a href="classslt_1_1DenseMatrix.html#a5eea42d2bdb71d69270abed1daf55168">More...</a><br /></td></tr>
<tr class="separator:a5eea42d2bdb71d69270abed1daf55168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36182695820d97a3e651f6cdb93faf0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a36182695820d97a3e651f6cdb93faf0a">operator/</a> (T scalar) const</td></tr>
<tr class="memdesc:a36182695820d97a3e651f6cdb93faf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide all matrix elements by a scalar.  <a href="classslt_1_1DenseMatrix.html#a36182695820d97a3e651f6cdb93faf0a">More...</a><br /></td></tr>
<tr class="separator:a36182695820d97a3e651f6cdb93faf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a6958aa43a7ead237b48114527ef5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a09a6958aa43a7ead237b48114527ef5b">transpose</a> ()</td></tr>
<tr class="memdesc:a09a6958aa43a7ead237b48114527ef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the matrix in-place.  <a href="classslt_1_1DenseMatrix.html#a09a6958aa43a7ead237b48114527ef5b">More...</a><br /></td></tr>
<tr class="separator:a09a6958aa43a7ead237b48114527ef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7443b52dd5c9229b1e57836c62734e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ae7443b52dd5c9229b1e57836c62734e5">inverse</a> () const</td></tr>
<tr class="memdesc:ae7443b52dd5c9229b1e57836c62734e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the inverse of a square matrix.  <a href="classslt_1_1DenseMatrix.html#ae7443b52dd5c9229b1e57836c62734e5">More...</a><br /></td></tr>
<tr class="separator:ae7443b52dd5c9229b1e57836c62734e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6666df109b2705e298cae85028014b6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ae6666df109b2705e298cae85028014b6">rows</a> () const override</td></tr>
<tr class="memdesc:ae6666df109b2705e298cae85028014b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the matrix.  <a href="classslt_1_1DenseMatrix.html#ae6666df109b2705e298cae85028014b6">More...</a><br /></td></tr>
<tr class="separator:ae6666df109b2705e298cae85028014b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac182317252d8e104ea9be539358fe1b2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ac182317252d8e104ea9be539358fe1b2">cols</a> () const override</td></tr>
<tr class="memdesc:ac182317252d8e104ea9be539358fe1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the matrix.  <a href="classslt_1_1DenseMatrix.html#ac182317252d8e104ea9be539358fe1b2">More...</a><br /></td></tr>
<tr class="separator:ac182317252d8e104ea9be539358fe1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64113fe72d74abc3e8f957e5f0bbee9e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a64113fe72d74abc3e8f957e5f0bbee9e">get</a> (std::size_t row, std::size_t col) const override</td></tr>
<tr class="memdesc:a64113fe72d74abc3e8f957e5f0bbee9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a copy of the value at the specified matrix index.  <a href="classslt_1_1DenseMatrix.html#a64113fe72d74abc3e8f957e5f0bbee9e">More...</a><br /></td></tr>
<tr class="separator:a64113fe72d74abc3e8f957e5f0bbee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7efc75ec0ecfa24c628b422f73f53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53">set</a> (std::size_t row, std::size_t col, T value) override</td></tr>
<tr class="memdesc:a06b7efc75ec0ecfa24c628b422f73f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value at the given matrix index, marking it as initialized.  <a href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53">More...</a><br /></td></tr>
<tr class="separator:a06b7efc75ec0ecfa24c628b422f73f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55af06b38c452c75279bbfe4d0abaf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ae55af06b38c452c75279bbfe4d0abaf4">remove</a> (std::size_t row, std::size_t col)</td></tr>
<tr class="memdesc:ae55af06b38c452c75279bbfe4d0abaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a value from the matrix by clearing its data and initialization flag.  <a href="classslt_1_1DenseMatrix.html#ae55af06b38c452c75279bbfe4d0abaf4">More...</a><br /></td></tr>
<tr class="separator:ae55af06b38c452c75279bbfe4d0abaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051172f51cb694e62d2ac92212e2b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#aa051172f51cb694e62d2ac92212e2b42">update</a> (std::size_t row, std::size_t col, T value)</td></tr>
<tr class="memdesc:aa051172f51cb694e62d2ac92212e2b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value at the given matrix index, assuming it is already initialized.  <a href="classslt_1_1DenseMatrix.html#aa051172f51cb694e62d2ac92212e2b42">More...</a><br /></td></tr>
<tr class="separator:aa051172f51cb694e62d2ac92212e2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf4b77281db6ded265fc44f8b3a309"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classslt_1_1MatrixBase.html">MatrixBase</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a66bf4b77281db6ded265fc44f8b3a309">clone</a> () const override</td></tr>
<tr class="memdesc:a66bf4b77281db6ded265fc44f8b3a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the current matrix instance.  <a href="classslt_1_1DenseMatrix.html#a66bf4b77281db6ded265fc44f8b3a309">More...</a><br /></td></tr>
<tr class="separator:a66bf4b77281db6ded265fc44f8b3a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0439627319cdaed291451c4135c33c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a0439627319cdaed291451c4135c33c2b">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:a0439627319cdaed291451c4135c33c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the matrix to the given output stream.  <a href="classslt_1_1DenseMatrix.html#a0439627319cdaed291451c4135c33c2b">More...</a><br /></td></tr>
<tr class="separator:a0439627319cdaed291451c4135c33c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc5061bed3861b391292058e43ae1b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#aecc5061bed3861b391292058e43ae1b2">is_initialized</a> (std::size_t row, std::size_t col) const override</td></tr>
<tr class="memdesc:aecc5061bed3861b391292058e43ae1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a specific matrix element has been initialized.  <a href="classslt_1_1DenseMatrix.html#aecc5061bed3861b391292058e43ae1b2">More...</a><br /></td></tr>
<tr class="separator:aecc5061bed3861b391292058e43ae1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classslt_1_1MatrixBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classslt_1_1MatrixBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classslt_1_1MatrixBase.html">slt::MatrixBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1MatrixBase.html#a3bbb4cd026c2c1da1ba0881c918630b1">~MatrixBase</a> ()=default</td></tr>
<tr class="memdesc:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for safe polymorphic deletion.  <a href="classslt_1_1MatrixBase.html#a3bbb4cd026c2c1da1ba0881c918630b1">More...</a><br /></td></tr>
<tr class="separator:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab63789902cfdc1e5cbf8e0777f5c9fb9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ab63789902cfdc1e5cbf8e0777f5c9fb9">data</a> = nullptr</td></tr>
<tr class="memdesc:ab63789902cfdc1e5cbf8e0777f5c9fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat row-major storage of matrix elements.  <a href="classslt_1_1DenseMatrix.html#ab63789902cfdc1e5cbf8e0777f5c9fb9">More...</a><br /></td></tr>
<tr class="separator:ab63789902cfdc1e5cbf8e0777f5c9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860a596275b6746c9c8e4a39a8671f5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#ae860a596275b6746c9c8e4a39a8671f5">init</a> = nullptr</td></tr>
<tr class="memdesc:ae860a596275b6746c9c8e4a39a8671f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containin a binary representation of array initialization.  <a href="classslt_1_1DenseMatrix.html#ae860a596275b6746c9c8e4a39a8671f5">More...</a><br /></td></tr>
<tr class="separator:ae860a596275b6746c9c8e4a39a8671f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cee72c413fc6a704706569e9571243d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a1cee72c413fc6a704706569e9571243d">rows_</a> = 0</td></tr>
<tr class="memdesc:a1cee72c413fc6a704706569e9571243d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows.  <a href="classslt_1_1DenseMatrix.html#a1cee72c413fc6a704706569e9571243d">More...</a><br /></td></tr>
<tr class="separator:a1cee72c413fc6a704706569e9571243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff8f8302614df9bc21407878384eaf2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1DenseMatrix.html#a8ff8f8302614df9bc21407878384eaf2">cols_</a> = 0</td></tr>
<tr class="memdesc:a8ff8f8302614df9bc21407878384eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cols.  <a href="classslt_1_1DenseMatrix.html#a8ff8f8302614df9bc21407878384eaf2">More...</a><br /></td></tr>
<tr class="separator:a8ff8f8302614df9bc21407878384eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class slt::DenseMatrix&lt; T &gt;</h3>

<p>A dense matrix implementation supporting float or double values. </p>
<p>Stores matrix elements in a contiguous 1D vector using row-major order. Supports basic arithmetic operations, element access, cloning, and transposition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be float or double. Enforced via static assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#_a40">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aefb68f3c5f27bd69a67d1e1f7b51831e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb68f3c5f27bd69a67d1e1f7b51831e">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix with given dimensions and fills it with a specified value. </p>
<p>This constructor initializes all elements of the matrix to a given value and marks them as initialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric data type of matrix elements. Must be either <code>float</code> or <code>double</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to each matrix element.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span>  <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3, 5.0f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* ptr = mat.data_ptr();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; mat.size(); ++i)</div>
<div class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassslt_1_1DenseMatrix_html"><div class="ttname"><a href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a></div><div class="ttdoc">A dense matrix implementation supporting float or double values.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:736</div></div>
<div class="ttc" id="amatrix_8hpp_html"><div class="ttname"><a href="matrix_8hpp.html">matrix.hpp</a></div></div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">5 5 5 5 5 5</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a20">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a85b119a507ec3de68409be6404505239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b119a507ec3de68409be6404505239">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix with given dimensions and zero-initializes all elements. </p>
<p>This constructor sets all values in the matrix to zero and marks them as uninitialized. It is typically used when data will be populated later via <code><a class="el" href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53" title="Sets the value at the given matrix index, marking it as initialized.">set()</a></code> or similar methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span>  <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3);</div>
<div class="line">    mat.set(0, 1, 42.0f);</div>
<div class="line">    mat.set(1, 2, 7.0f);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* ptr = mat.data_ptr();</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; mat.size(); ++i)</div>
<div class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized count: &quot;</span> &lt;&lt; mat.nonzero_count() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">0 42 0 0 0 7</div>
<div class="line">Initialized count: 2</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a04b54af6e439372387f32809fdb354eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b54af6e439372387f32809fdb354eb">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a nested std::vector of values. </p>
<p>Initializes the matrix with the contents of a row-major nested <code>std::vector</code>. All rows must have the same number of columns, otherwise an exception is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric data type of matrix elements. Must be either <code>float</code> or <code>double</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A 2D vector representing matrix data in row-major order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if rows have inconsistent sizes.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; values = {</div>
<div class="line">    {1.0f, 2.0f},</div>
<div class="line">    {3.0f, 4.0f}</div>
<div class="line">};</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(values);</div>
<div class="line">std::cout &lt;&lt; mat.get(1, 0); <span class="comment">// Output: 3.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1527e4de225bc7b3537e3c4a1af474f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1527e4de225bc7b3537e3c4a1af474f3">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;std::size_t Rows, std::size_t Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, Cols &gt;, Rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a fixed-size std::array of std::array values. </p>
<p>This constructor allows initializing a matrix from a compile-time known 2D <code>std::array</code> layout. The matrix is fully initialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>Number of rows (inferred at compile time) </td></tr>
    <tr><td class="paramname">Cols</td><td>Number of columns (inferred at compile time) </td></tr>
    <tr><td class="paramname">T</td><td>Numeric data type of matrix elements. Must be either <code>float</code> or <code>double</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>A 2D array containing matrix values in row-major order.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::array&lt;std::array&lt;double, 2&gt;, 2&gt; arr = {{</div>
<div class="line">    {1.1, 1.2},</div>
<div class="line">    {2.1, 2.2}</div>
<div class="line">}};</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> mat(arr);</div>
<div class="line">std::cout &lt;&lt; mat.get(0, 1); <span class="comment">// Output: 1.2</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8cc9938ed4a846403bc6584ee47a9bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc9938ed4a846403bc6584ee47a9bd9">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from an initializer list of initializer lists. </p>
<p>Enables matrix initialization using brace-enclosed values in row-major order. All rows must be of equal length or an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_list</td><td>Nested initializer list representing the matrix contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if any row has inconsistent size.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat = {</div>
<div class="line">        {1.0f, 2.0f},</div>
<div class="line">        {3.0f, 4.0f}</div>
<div class="line">    };</div>
<div class="line">    std::cout &lt;&lt; mat.<a class="code" href="classslt_1_1DenseMatrix.html#a64113fe72d74abc3e8f957e5f0bbee9e">get</a>(1, 0); <span class="comment">// Output: 3.0</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassslt_1_1DenseMatrix_html_a64113fe72d74abc3e8f957e5f0bbee9e"><div class="ttname"><a href="classslt_1_1DenseMatrix.html#a64113fe72d74abc3e8f957e5f0bbee9e">slt::DenseMatrix::get</a></div><div class="ttdeci">T get(std::size_t row, std::size_t col) const override</div><div class="ttdoc">Retrieves a copy of the value at the specified matrix index.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:1743</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adcf2b60ad5bd47d6dabaf714dd1f6727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf2b60ad5bd47d6dabaf714dd1f6727">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>flat_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a flat data vector with explicit dimensions. </p>
<p>The data must be laid out in row-major order, and the vector must have exactly <code>rows * cols</code> elements. All elements are marked initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flat_data</td><td>Flat vector of values in row-major order. </td></tr>
    <tr><td class="paramname">r</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the data size does not match r * c.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::vector&lt;double&gt; <a class="code" href="classslt_1_1DenseMatrix.html#ab63789902cfdc1e5cbf8e0777f5c9fb9">data</a> = {1.0, 2.0, 3.0, 4.0};</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> mat(<a class="code" href="classslt_1_1DenseMatrix.html#ab63789902cfdc1e5cbf8e0777f5c9fb9">data</a>, 2, 2);</div>
<div class="line">    std::cout &lt;&lt; mat.get(0, 1); <span class="comment">// Output: 2.0</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassslt_1_1DenseMatrix_html_ab63789902cfdc1e5cbf8e0777f5c9fb9"><div class="ttname"><a href="classslt_1_1DenseMatrix.html#ab63789902cfdc1e5cbf8e0777f5c9fb9">slt::DenseMatrix::data</a></div><div class="ttdeci">std::vector&lt; T &gt; data</div><div class="ttdoc">Flat row-major storage of matrix elements.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:741</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a48b3d24ccb26cc6fba021da75cdca42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b3d24ccb26cc6fba021da75cdca42e">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a flat std::array with specified dimensions. </p>
<p>The flat array must be laid out in row-major order and its size must exactly match <code>rows * cols</code>. All elements are marked initialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of the flat std::array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Flat array containing matrix data in row-major order. </td></tr>
    <tr><td class="paramname">r</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if N does not match r * c.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::array&lt;float, 6&gt; arr = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(arr, 2, 3);</div>
<div class="line">    std::cout &lt;&lt; mat.get(1, 2); <span class="comment">// Output: 6.0</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac64fec350273642bd69b2500001c63be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64fec350273642bd69b2500001c63be">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>. </p>
<p>Creates a deep copy of another <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>, duplicating its internal data and initialization state. The resulting matrix is independent of the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> instance to copy.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> A(2, 2, 1.0);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> B(A);  <span class="comment">// B is a deep copy of A</span></div>
<div class="line">std::cout &lt;&lt; B.get(0, 0);        <span class="comment">// Output: 1.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acfda95ba96454680c4339e636195c58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfda95ba96454680c4339e636195c58b">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>. </p>
<p>Transfers ownership of the internal data from another <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>. This is a lightweight operation that avoids deep copying, and the original matrix is left in a valid but empty state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> to move from. It will be reset to a zero-sized state.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(3, 3, 2.0f);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> B = std::move(A);  <span class="comment">// B takes ownership of A&#39;s data</span></div>
<div class="line">std::cout &lt;&lt; B.<a class="code" href="classslt_1_1DenseMatrix.html#a64113fe72d74abc3e8f957e5f0bbee9e">get</a>(2, 2);                  <span class="comment">// Output: 2.0</span></div>
<div class="line">std::cout &lt;&lt; A.size();                     <span class="comment">// Output: 0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4755d6afb58a6cb916b70a153f4aa7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4755d6afb58a6cb916b70a153f4aa7ef">&#9670;&nbsp;</a></span>DenseMatrix() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a square identity matrix of size n x n. </p>
<p>This constructor initializes a square matrix with 1s on the main diagonal and 0s elsewhere. It marks all diagonal entries as initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Size of the identity matrix (rows and columns).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if n is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a66bf4b77281db6ded265fc44f8b3a309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bf4b77281db6ded265fc44f8b3a309">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classslt_1_1MatrixBase.html">MatrixBase</a>&lt;T&gt; &gt; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of the current matrix instance. </p>
<p>This method returns a new <code><a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a></code> object that is a deep copy of the current matrix. The returned pointer is cast to the base class <code><a class="el" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types.">MatrixBase</a>&lt;T&gt;</code> and stored in a <code>std::unique_ptr</code> for memory-safe polymorphic use.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::unique_ptr</code> to a new copy of this matrix.</dd></dl>
<div class="fragment"><div class="line">std::unique_ptr&lt;MatrixBase&lt;float&gt;&gt; original = std::make_unique&lt;slt::DenseMatrix&lt;float&gt;&gt;(2, 2);</div>
<div class="line">std::unique_ptr&lt;MatrixBase&lt;float&gt;&gt; copy = original-&gt;clone();</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a10ca9a5de506b53de715596507c77321">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a35">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac182317252d8e104ea9be539358fe1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac182317252d8e104ea9be539358fe1b2">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the matrix. </p>
<p>This function provides access to the total number of columns stored in the matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of columns in the matrix.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(3, 5);</div>
<div class="line">std::cout &lt;&lt; mat.cols();  <span class="comment">// Outputs: 5</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#acee40c97e44474a9619b808b63d1868b">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a30">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4cdc9d44da3d03b7941e9eb1eec36340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdc9d44da3d03b7941e9eb1eec36340">&#9670;&nbsp;</a></span>data_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::data_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first value within the data array. </p>
<p>Returns a pointer to the beginning of the matrix's internal data array, stored in row-major order. This is useful for passing the data to low-level numerical libraries or performing custom SIMD operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the beginning of the matrix data in contiguous memory. Returns nullptr if not initialized</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span> <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3, 1.5f);</div>
<div class="line">    <span class="keywordtype">float</span>* ptr = mat.data_ptr();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; mat.size(); ++i)</div>
<div class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">1.5 1.5 1.5 1.5 1.5 1.5</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a529848163b44a2168460198adda171f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529848163b44a2168460198adda171f7">&#9670;&nbsp;</a></span>data_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::data_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first value within the data array. </p>
<p>Returns a pointer to the beginning of the matrix's internal data array, stored in row-major order. This is useful for passing the data to low-level numerical libraries or performing custom SIMD operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the beginning of the matrix data in contiguous memory. Returns nullptr if not initialized</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span> <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3, 1.5f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* ptr = mat.data_ptr();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; mat.size(); ++i)</div>
<div class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">1.5 1.5 1.5 1.5 1.5 1.5</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a17">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a64113fe72d74abc3e8f957e5f0bbee9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64113fe72d74abc3e8f957e5f0bbee9e">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a copy of the value at the specified matrix index. </p>
<p>This method allows read-only access to an individual matrix element. If the index is out of bounds or the element is uninitialized, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index </td></tr>
    <tr><td class="paramname">col</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value at the specified index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>row</code> or <code>col</code> is outside the matrix bounds. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the element at the given index is uninitialized.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> mat(3, 3);</div>
<div class="line">mat.set(1, 1, 42.0);</div>
<div class="line">std::cout &lt;&lt; mat.get(1, 1);  <span class="comment">// Outputs: 42.0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat.get(0, 0);  // Would throw std::runtime_error</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a5fe460dc2d97ee440c32635d5f3192fc">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a31">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a631142d8a7cbb38a6e8210569e8605d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631142d8a7cbb38a6e8210569e8605d4">&#9670;&nbsp;</a></span>init_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::init_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first value within the init array. </p>
<p>Returns a pointer to the beginning of the matrix's internal init array, stored in row-major order. This is may be useful for debugging issues if initialized data is showing as uninitialized</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the beginning of the matrix data in contiguous memory. Returns nullptr if not initialized</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span> <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3);</div>
<div class="line">    mat.set(0, 0, 1.0f);</div>
<div class="line">    mat.set(0, 1, 2.0f);</div>
<div class="line">    uint8_t* ptr = mat.init_ptr();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; mat.size(); ++i)</div>
<div class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">1, 1, 0, 0, 0, 0</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a18">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae7443b52dd5c9229b1e57836c62734e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7443b52dd5c9229b1e57836c62734e5">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt;T&gt; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the inverse of a square matrix. </p>
<p>This function implements Gauss-Jordan elimination with partial pivoting. It throws if the matrix is not square or is singular (i.e., non-invertible).</p>
<p>All elements of the result are marked as initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> object containing the inverse.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the matrix is not square. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the matrix is singular and cannot be inverted.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> mat({</div>
<div class="line">    {4.0, 7.0},</div>
<div class="line">    {2.0, 6.0}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> inv = mat.<a class="code" href="classslt_1_1DenseMatrix.html#ae7443b52dd5c9229b1e57836c62734e5">inverse</a>();</div>
<div class="line">std::cout &lt;&lt; inv(0, 0);  <span class="comment">// Outputs approximately 0.6</span></div>
<div class="line">std::cout &lt;&lt; inv(1, 1);  <span class="comment">// Outputs approximately 0.4</span></div>
<div class="ttc" id="aclassslt_1_1DenseMatrix_html_ae7443b52dd5c9229b1e57836c62734e5"><div class="ttname"><a href="classslt_1_1DenseMatrix.html#ae7443b52dd5c9229b1e57836c62734e5">slt::DenseMatrix::inverse</a></div><div class="ttdeci">DenseMatrix&lt; T &gt; inverse() const</div><div class="ttdoc">Computes and returns the inverse of a square matrix.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:1629</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a28">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="aecc5061bed3861b391292058e43ae1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc5061bed3861b391292058e43ae1b2">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::is_initialized </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a specific matrix element has been initialized. </p>
<p>Returns <code>true</code> if the element at the specified row and column has been initialized using <code><a class="el" href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53" title="Sets the value at the given matrix index, marking it as initialized.">set()</a></code>, <code><a class="el" href="classslt_1_1DenseMatrix.html#aa051172f51cb694e62d2ac92212e2b42" title="Updates the value at the given matrix index, assuming it is already initialized.">update()</a></code>, or the assignment operator. Otherwise, returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index </td></tr>
    <tr><td class="paramname">col</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element is initialized, <code>false</code> otherwise</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is outside the matrix bounds</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(3, 3);</div>
<div class="line">mat.set(1, 1, 2.0f);</div>
<div class="line"><span class="keywordtype">bool</span> check = mat.is_initialized(1, 1);  <span class="comment">// true</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a069249b28295c9776df81efed6076589">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a37">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a33d3181181df8997b1f81135ba6fe1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d3181181df8997b1f81135ba6fe1d2">&#9670;&nbsp;</a></span>nonzero_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::nonzero_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of initialized elements in the matrix. </p>
<p>This function scans the internal <code>init</code> vector and returns the number of elements that have been explicitly initialized. This allows tracking sparse-style usage in a dense matrix implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of initialized elements in the matrix.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span>  <span class="comment">// assuming DenseMatrix is defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3);</div>
<div class="line">    mat.set(0, 0, 3.14f);</div>
<div class="line">    mat.set(1, 1, 2.71f);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized elements: &quot;</span> &lt;&lt; mat.nonzero_count() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">Initialized elements: 2</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a19">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a77c081ccac829706e7b345faf2acf42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c081ccac829706e7b345faf2acf42d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access or assign a value at the specified matrix index (r, c). </p>
<p>This non-const overload allows users to assign a value to an element. If the element has not been previously initialized (tracked via the internal <code>init</code> vector), it will be marked as initialized. If already initialized, it acts as a regular update.</p>
<p>Bounds checking is performed; if the index is out of range, std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index </td></tr>
    <tr><td class="paramname">c</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the value at the specified index</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3);</div>
<div class="line">mat(0, 1) = 4.2f;  <span class="comment">// Initializes and sets the value</span></div>
<div class="line">mat(0, 1) = 5.0f;  <span class="comment">// Updates existing value</span></div>
<div class="line">std::cout &lt;&lt; mat(0, 1);  <span class="comment">// Outputs: 5.0</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a21">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a031fc322b994002ef9c2c10540a99603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031fc322b994002ef9c2c10540a99603">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to a matrix element at (r, c). </p>
<p>This const overload allows read-only access to a matrix element. Throws a std::runtime_error if the element has not been initialized via <code><a class="el" href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53" title="Sets the value at the given matrix index, marking it as initialized.">set()</a></code>, <code>operator()</code>, or <code><a class="el" href="classslt_1_1DenseMatrix.html#aa051172f51cb694e62d2ac92212e2b42" title="Updates the value at the given matrix index, assuming it is already initialized.">update()</a></code>.</p>
<p>Bounds checking is performed; if the index is out of range, std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index </td></tr>
    <tr><td class="paramname">c</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the initialized value at (r, c)</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 3);</div>
<div class="line">mat.set(1, 2, 8.5f);</div>
<div class="line">std::cout &lt;&lt; mat(1, 2);  <span class="comment">// Outputs: 8.5</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat(0, 0); // Would throw std::runtime_error since it&#39;s uninitialized</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab28b2210e92edcb57fb8d042e185571f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28b2210e92edcb57fb8d042e185571f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise matrix multiplication. </p>
<p>Multiplies this matrix element-wise with another matrix of the same dimensions. Throws an exception if the matrices differ in shape. Uses SIMD acceleration if supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> containing the element-wise product.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if matrix dimensions do not match.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(2, 2);</div>
<div class="line">A.set(0, 0, 2.0f); A.set(0, 1, 3.0f);</div>
<div class="line">A.set(1, 0, 4.0f); A.set(1, 1, 5.0f);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> B(2, 2, 2.0f);  <span class="comment">// filled with 2.0</span></div>
<div class="line"><span class="keyword">auto</span> C = A * B;</div>
<div class="line">std::cout &lt;&lt; C(0, 0);  <span class="comment">// Outputs: 4.0</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a25">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5eea42d2bdb71d69270abed1daf55168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eea42d2bdb71d69270abed1daf55168">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply all matrix elements by a scalar. </p>
<p>Returns a new matrix with each element multiplied by the provided scalar value. This operation uses SIMD acceleration if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Value to multiply each matrix element by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> containing the scaled values.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> A(2, 2, 3.0);</div>
<div class="line"><span class="keyword">auto</span> B = A * 2.0;</div>
<div class="line">std::cout &lt;&lt; B(1, 1);  <span class="comment">// Outputs: 6.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a01bfb57f1f4c7f11110926bd3625834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bfb57f1f4c7f11110926bd3625834a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> objects element-wise. </p>
<p>Performs element-wise addition between two matrices of equal dimensions. If SIMD is supported, the addition is vectorized for performance.</p>
<p>The returned matrix will be fully initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> containing the sum of the current matrix and <code>other</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if matrix dimensions do not match.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(2, 2, 1.0f);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> B(2, 2, 2.0f);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> C = A + B;</div>
<div class="line">std::cout &lt;&lt; C(0, 0);  <span class="comment">// Outputs: 3.0</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a23">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a76746086f9f6b50cd82d09b7d648b38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76746086f9f6b50cd82d09b7d648b38e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scalar to all elements of the matrix. </p>
<p>Each element of the matrix is incremented by the given scalar value. The result is stored in a new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> that is fully initialized. SIMD acceleration is used if supported by the platform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The value to add to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> containing the result of the scalar addition.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(2, 2, 1.0f);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> B = A + 3.0f;</div>
<div class="line">std::cout &lt;&lt; B(0, 0);  <span class="comment">// Outputs: 4.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a64a5482eb0dbba6aa16825fda6eac2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a5482eb0dbba6aa16825fda6eac2ac">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise matrix subtraction. </p>
<p>Subtracts another <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> from this matrix element-wise. Both matrices must have the same shape, otherwise an exception is thrown. If SIMD is supported, subtraction is performed using optimized SIMD instructions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Matrix to subtract from this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> representing the result of the subtraction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if matrix dimensions do not match.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(2, 2, 4.0f);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> B(2, 2, 1.0f);</div>
<div class="line"><span class="keyword">auto</span> C = A - B;</div>
<div class="line"><span class="comment">// C now contains all 3.0 values</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a24">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a97d52da76847341fc62f9101b961d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d52da76847341fc62f9101b961d98d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction from all elements of the matrix. </p>
<p>Subtracts a scalar value from each element in the matrix. If SIMD is available, it uses optimized instructions for faster execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Value to subtract from each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> containing the result.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> mat(2, 2, 5.0);</div>
<div class="line"><span class="keyword">auto</span> result = mat - 2.0;</div>
<div class="line"><span class="comment">// result contains all 3.0 values</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a36182695820d97a3e651f6cdb93faf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36182695820d97a3e651f6cdb93faf0a">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a> <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide all matrix elements by a scalar. </p>
<p>Returns a new matrix with each element divided by the given scalar value. Uses SIMD acceleration if available. Division by zero is explicitly checked and will throw an exception if detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a> with scaled-down values.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if scalar is zero.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> A(2, 2, 8.0f);</div>
<div class="line"><span class="keyword">auto</span> B = A / 2.0f;</div>
<div class="line">std::cout &lt;&lt; B(0, 0);  <span class="comment">// Outputs: 4.0</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a26">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4f16ef2fe485bfeaff37e07be5cbb437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f16ef2fe485bfeaff37e07be5cbb437">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt;T&gt;&amp; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>. </p>
<p>Copies the contents of another matrix, including data values, initialization status, and dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the current matrix after copy.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> A(2, 2, 1.0);</div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> B = A;  <span class="comment">// uses copy constructor</span></div>
<div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;double&gt;</a> C;</div>
<div class="line">C = A;  <span class="comment">// uses copy assignment</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a22">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2edb94832d0cb9421cfe9e85b8d56b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edb94832d0cb9421cfe9e85b8d56b33">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt;T&gt;&amp; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="classslt_1_1DenseMatrix.html" title="A dense matrix implementation supporting float or double values.">DenseMatrix</a>. </p>
<p>Transfers ownership of the resources from another matrix to this one. After the move, the source matrix is left in a valid but unspecified state (typically zero dimensions and empty internal buffers).</p>
<p>This is useful for efficient reassignment of temporary matrices without deep copying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source matrix to move from (rvalue reference). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this matrix after move assignment.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span>  <span class="comment">// For std::move</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat1(2, 2, 3.0f);</div>
<div class="line">    <a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat2;</div>
<div class="line"> </div>
<div class="line">    mat2 = std::move(mat1);  <span class="comment">// Efficient resource transfer</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; mat2(0, 0);  <span class="comment">// Outputs: 3.0</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// mat1 is now in a valid but empty state</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Size after move: &quot;</span> &lt;&lt; mat1.size();  <span class="comment">// Outputs: 0</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0439627319cdaed291451c4135c33c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0439627319cdaed291451c4135c33c2b">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the contents of the matrix to the given output stream. </p>
<p>Displays the matrix in a human-readable 2D format. Each element is printed with fixed width spacing for readability. The default stream is <code>std::cout</code>, but any <code>std::ostream</code> can be passed (e.g., <code>std::ostringstream</code> for testing).</p>
<p>Only initialized elements are printed. Uninitialized elements accessed through this method may trigger runtime exceptions if bounds or initialization are violated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to print to (defaults to <code>std::cout</code>)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;int&gt;</a> mat(2, 3);</div>
<div class="line">mat.set(0, 0, 1);</div>
<div class="line">mat.set(0, 1, 2);</div>
<div class="line">mat.set(0, 2, 3);</div>
<div class="line">mat.set(1, 0, 4);</div>
<div class="line">mat.set(1, 1, 5);</div>
<div class="line">mat.set(1, 2, 6);</div>
<div class="line">mat.print();</div>
</div><!-- fragment --><p>Output: </p><pre class="fragment">*          1          2          3 
*          4          5          6 
* </pre> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a36">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae55af06b38c452c75279bbfe4d0abaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55af06b38c452c75279bbfe4d0abaf4">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a value from the matrix by clearing its data and initialization flag. </p>
<p>This function resets the element at (row, col) to the default value of type <code>T</code> and marks it as uninitialized. If the value was not initialized to begin with, an error is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index </td></tr>
    <tr><td class="paramname">col</td><td>Column index</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is invalid </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the element was not initialized</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(2, 2);</div>
<div class="line">mat.set(0, 1, 3.14f);</div>
<div class="line">mat.remove(0, 1);  <span class="comment">// Successfully removes</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat.remove(0, 1);  // Throws std::runtime_error</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a33">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae6666df109b2705e298cae85028014b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6666df109b2705e298cae85028014b6">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the matrix. </p>
<p>This function provides access to the total number of rows stored in the matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of rows in the matrix.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(3, 5);</div>
<div class="line">std::cout &lt;&lt; mat.rows();  <span class="comment">// Outputs: 3</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#af5247088bf3743574e25430da458ff46">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a29">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a06b7efc75ec0ecfa24c628b422f73f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b7efc75ec0ecfa24c628b422f73f53">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value at the given matrix index, marking it as initialized. </p>
<p>This function assigns a value to the matrix at position (row, col), but only if the element is currently uninitialized. If the element is already initialized, it throws an exception. Use <code><a class="el" href="classslt_1_1DenseMatrix.html#aa051172f51cb694e62d2ac92212e2b42" title="Updates the value at the given matrix index, assuming it is already initialized.">update()</a></code> instead to modify existing values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index </td></tr>
    <tr><td class="paramname">col</td><td>Column index </td></tr>
    <tr><td class="paramname">value</td><td>Value to assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is outside the matrix bounds </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the element is already initialized</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat(3, 3);</div>
<div class="line">mat.set(1, 2, 9.5f);  <span class="comment">// Initializes and sets value</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat.set(1, 2, 4.3f);  // Throws std::runtime_error</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a2925cbdba8ec46c258f8d8e1fb1b730d">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a32">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a02b7df353b3562388432f1bbbb8bab54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b7df353b3562388432f1bbbb8bab54">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total size of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows multiplied by the number of columns, 0 if not initialized </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a16">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a09a6958aa43a7ead237b48114527ef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a6958aa43a7ead237b48114527ef5b">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes the matrix in-place. </p>
<p>This function swaps the rows and columns of the matrix, modifying it directly. It is only applicable to dense matrices and is performed without creating a new object.</p>
<p>The <code>init</code> state of all elements is preserved.</p>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 2.0f},</div>
<div class="line">    {3.0f, 4.0f}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">mat.<a class="code" href="classslt_1_1DenseMatrix.html#a09a6958aa43a7ead237b48114527ef5b">transpose</a>();</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; mat(0, 1);  <span class="comment">// Outputs: 3.0</span></div>
<div class="line">std::cout &lt;&lt; mat(1, 0);  <span class="comment">// Outputs: 2.0</span></div>
<div class="ttc" id="aclassslt_1_1DenseMatrix_html_a09a6958aa43a7ead237b48114527ef5b"><div class="ttname"><a href="classslt_1_1DenseMatrix.html#a09a6958aa43a7ead237b48114527ef5b">slt::DenseMatrix::transpose</a></div><div class="ttdeci">void transpose()</div><div class="ttdoc">Transposes the matrix in-place.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:1593</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a27">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa051172f51cb694e62d2ac92212e2b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa051172f51cb694e62d2ac92212e2b42">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::update </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value at the given matrix index, assuming it is already initialized. </p>
<p>This method allows modifying the value of an element that has already been initialized. It does not change the initialization state. Use <code><a class="el" href="classslt_1_1DenseMatrix.html#a06b7efc75ec0ecfa24c628b422f73f53" title="Sets the value at the given matrix index, marking it as initialized.">set()</a></code> if the value is uninitialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row index </td></tr>
    <tr><td class="paramname">col</td><td>Column index </td></tr>
    <tr><td class="paramname">value</td><td>New value to assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is out of bounds </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the target element is uninitialized</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix&lt;int&gt;</a> mat(3, 3);</div>
<div class="line">mat.set(2, 1, 5);</div>
<div class="line">mat.update(2, 1, 10);  <span class="comment">// Replaces value</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// mat.update(0, 0, 1);  // Throws std::runtime_error if not previously set</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a34">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8ff8f8302614df9bc21407878384eaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff8f8302614df9bc21407878384eaf2">&#9670;&nbsp;</a></span>cols_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::cols_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of cols. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a15">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab63789902cfdc1e5cbf8e0777f5c9fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63789902cfdc1e5cbf8e0777f5c9fb9">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::data = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flat row-major storage of matrix elements. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a12">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae860a596275b6746c9c8e4a39a8671f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae860a596275b6746c9c8e4a39a8671f5">&#9670;&nbsp;</a></span>init</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::init = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector containin a binary representation of array initialization. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a13">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1cee72c413fc6a704706569e9571243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cee72c413fc6a704706569e9571243d">&#9670;&nbsp;</a></span>rows_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1DenseMatrix.html">slt::DenseMatrix</a>&lt; T &gt;::rows_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a14">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
