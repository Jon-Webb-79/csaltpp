<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csalt++: slt::SparseCOOMatrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">csalt++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceslt.html">slt</a></li><li class="navelem"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classslt_1_1SparseCOOMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">slt::SparseCOOMatrix&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A sparse matrix implementation using the Coordinate List (COO) format.  
 <a href="classslt_1_1SparseCOOMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for slt::SparseCOOMatrix&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classslt_1_1SparseCOOMatrix__inherit__graph.png" border="0" usemap="#aslt_1_1SparseCOOMatrix_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aslt_1_1SparseCOOMatrix_3_01T_01_4_inherit__map" id="aslt_1_1SparseCOOMatrix_3_01T_01_4_inherit__map">
<area shape="rect" title="A sparse matrix implementation using the Coordinate List (COO) format." alt="" coords="5,80,204,107"/>
<area shape="rect" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types." alt="" coords="25,5,184,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for slt::SparseCOOMatrix&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classslt_1_1SparseCOOMatrix__coll__graph.png" border="0" usemap="#aslt_1_1SparseCOOMatrix_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aslt_1_1SparseCOOMatrix_3_01T_01_4_coll__map" id="aslt_1_1SparseCOOMatrix_3_01T_01_4_coll__map">
<area shape="rect" title="A sparse matrix implementation using the Coordinate List (COO) format." alt="" coords="5,80,204,107"/>
<area shape="rect" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types." alt="" coords="25,5,184,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslt_1_1SparseCOOMatrix_1_1COOComparator.html">COOComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc0211d7a6ffae48b7e796d5f9dacd15"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#adc0211d7a6ffae48b7e796d5f9dacd15">size</a> () const override</td></tr>
<tr class="memdesc:adc0211d7a6ffae48b7e796d5f9dacd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the matrix.  <a href="classslt_1_1SparseCOOMatrix.html#adc0211d7a6ffae48b7e796d5f9dacd15">More...</a><br /></td></tr>
<tr class="separator:adc0211d7a6ffae48b7e796d5f9dacd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daf5e8c69cd9f68f468cd41e06cd45e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a5daf5e8c69cd9f68f468cd41e06cd45e">nonzero_count</a> () const override</td></tr>
<tr class="memdesc:a5daf5e8c69cd9f68f468cd41e06cd45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of explicitly stored non-zero elements.  <a href="classslt_1_1SparseCOOMatrix.html#a5daf5e8c69cd9f68f468cd41e06cd45e">More...</a><br /></td></tr>
<tr class="separator:a5daf5e8c69cd9f68f468cd41e06cd45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f9d4289054f90dc5248edee3385f2d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a26f9d4289054f90dc5248edee3385f2d">row_index</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a26f9d4289054f90dc5248edee3385f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row index of the i-th non-zero element.  <a href="classslt_1_1SparseCOOMatrix.html#a26f9d4289054f90dc5248edee3385f2d">More...</a><br /></td></tr>
<tr class="separator:a26f9d4289054f90dc5248edee3385f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d82d6bb156ed5dbb372bb7c8155b7d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a0d82d6bb156ed5dbb372bb7c8155b7d5">col_index</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a0d82d6bb156ed5dbb372bb7c8155b7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column index of the i-th non-zero element.  <a href="classslt_1_1SparseCOOMatrix.html#a0d82d6bb156ed5dbb372bb7c8155b7d5">More...</a><br /></td></tr>
<tr class="separator:a0d82d6bb156ed5dbb372bb7c8155b7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41de6aa5a303e7997a29c1d4422477b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ae41de6aa5a303e7997a29c1d4422477b">value_index</a> (std::size_t i) const</td></tr>
<tr class="memdesc:ae41de6aa5a303e7997a29c1d4422477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the i-th non-zero element.  <a href="classslt_1_1SparseCOOMatrix.html#ae41de6aa5a303e7997a29c1d4422477b">More...</a><br /></td></tr>
<tr class="separator:ae41de6aa5a303e7997a29c1d4422477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf817cb3a1cfdd63825edd72b7af332"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#afdf817cb3a1cfdd63825edd72b7af332">SparseCOOMatrix</a> (std::size_t r, std::size_t c, bool fastInsert=true)</td></tr>
<tr class="memdesc:afdf817cb3a1cfdd63825edd72b7af332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty sparse COO matrix with given dimensions.  <a href="classslt_1_1SparseCOOMatrix.html#afdf817cb3a1cfdd63825edd72b7af332">More...</a><br /></td></tr>
<tr class="separator:afdf817cb3a1cfdd63825edd72b7af332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0556e77c2ab536d1e9f98924ebc00325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a0556e77c2ab536d1e9f98924ebc00325">SparseCOOMatrix</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vec, bool fastInsert=true)</td></tr>
<tr class="memdesc:a0556e77c2ab536d1e9f98924ebc00325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse COO matrix from a 2D std::vector.  <a href="classslt_1_1SparseCOOMatrix.html#a0556e77c2ab536d1e9f98924ebc00325">More...</a><br /></td></tr>
<tr class="separator:a0556e77c2ab536d1e9f98924ebc00325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1823148f7dd13b5e31c55c218d31f8ab"><td class="memTemplParams" colspan="2">template&lt;std::size_t Rows, std::size_t Cols&gt; </td></tr>
<tr class="memitem:a1823148f7dd13b5e31c55c218d31f8ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a1823148f7dd13b5e31c55c218d31f8ab">SparseCOOMatrix</a> (const std::array&lt; std::array&lt; T, Cols &gt;, Rows &gt; &amp;arr, bool fastInsert=true)</td></tr>
<tr class="memdesc:a1823148f7dd13b5e31c55c218d31f8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse COO matrix from a fixed-size std::array.  <a href="classslt_1_1SparseCOOMatrix.html#a1823148f7dd13b5e31c55c218d31f8ab">More...</a><br /></td></tr>
<tr class="separator:a1823148f7dd13b5e31c55c218d31f8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf93130e5698de91ab00c3640497e7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#afdf93130e5698de91ab00c3640497e7c">SparseCOOMatrix</a> (std::initializer_list&lt; std::initializer_list&lt; T &gt;&gt; initList, bool fastInsert=true)</td></tr>
<tr class="memdesc:afdf93130e5698de91ab00c3640497e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse COO matrix from a nested initializer list.  <a href="classslt_1_1SparseCOOMatrix.html#afdf93130e5698de91ab00c3640497e7c">More...</a><br /></td></tr>
<tr class="separator:afdf93130e5698de91ab00c3640497e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae770b21eed338ffb9befcfdd9980018e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ae770b21eed338ffb9befcfdd9980018e">SparseCOOMatrix</a> (const std::vector&lt; T &gt; &amp;flat_data, std::size_t r, std::size_t c, bool fastInsert=true)</td></tr>
<tr class="memdesc:ae770b21eed338ffb9befcfdd9980018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse COO matrix from a flat vector in row-major order.  <a href="classslt_1_1SparseCOOMatrix.html#ae770b21eed338ffb9befcfdd9980018e">More...</a><br /></td></tr>
<tr class="separator:ae770b21eed338ffb9befcfdd9980018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca17fa945fb3d058e784e9c448f257f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#aca17fa945fb3d058e784e9c448f257f0">SparseCOOMatrix</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aca17fa945fb3d058e784e9c448f257f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>.  <a href="classslt_1_1SparseCOOMatrix.html#aca17fa945fb3d058e784e9c448f257f0">More...</a><br /></td></tr>
<tr class="separator:aca17fa945fb3d058e784e9c448f257f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c524c58afeb267a0e3cd0bddc2b9be3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a6c524c58afeb267a0e3cd0bddc2b9be3">SparseCOOMatrix</a> (<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a6c524c58afeb267a0e3cd0bddc2b9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>.  <a href="classslt_1_1SparseCOOMatrix.html#a6c524c58afeb267a0e3cd0bddc2b9be3">More...</a><br /></td></tr>
<tr class="separator:a6c524c58afeb267a0e3cd0bddc2b9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb078adcd4c95de5d7bddbe438a06316"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#abb078adcd4c95de5d7bddbe438a06316">operator()</a> (std::size_t r, std::size_t c) const</td></tr>
<tr class="memdesc:abb078adcd4c95de5d7bddbe438a06316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a matrix element (read-only).  <a href="classslt_1_1SparseCOOMatrix.html#abb078adcd4c95de5d7bddbe438a06316">More...</a><br /></td></tr>
<tr class="separator:abb078adcd4c95de5d7bddbe438a06316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc02d00cac074d3771223b358de6152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a1dc02d00cac074d3771223b358de6152">operator==</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="separator:a1dc02d00cac074d3771223b358de6152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8066b8bab1b1db44570b043591547447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a8066b8bab1b1db44570b043591547447">operator=</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a8066b8bab1b1db44570b043591547447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy assignment operator.  <a href="classslt_1_1SparseCOOMatrix.html#a8066b8bab1b1db44570b043591547447">More...</a><br /></td></tr>
<tr class="separator:a8066b8bab1b1db44570b043591547447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7851db1ffece701e976625710f88aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ad7851db1ffece701e976625710f88aaf">operator=</a> (<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ad7851db1ffece701e976625710f88aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classslt_1_1SparseCOOMatrix.html#ad7851db1ffece701e976625710f88aaf">More...</a><br /></td></tr>
<tr class="separator:ad7851db1ffece701e976625710f88aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b8c482627448d29d112af92da1afb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a92b8c482627448d29d112af92da1afb8">operator+</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="separator:a92b8c482627448d29d112af92da1afb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1bd1320cb996c904f3f56d6897c9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#add1bd1320cb996c904f3f56d6897c9cf">operator+</a> (T scalar) const</td></tr>
<tr class="separator:add1bd1320cb996c904f3f56d6897c9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869a28d52e8cf7658dc8cc87a9bfcc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a869a28d52e8cf7658dc8cc87a9bfcc6d">operator-</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="separator:a869a28d52e8cf7658dc8cc87a9bfcc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db595de4e0815f91d5aba9765b942de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a1db595de4e0815f91d5aba9765b942de">operator-</a> (T scalar) const</td></tr>
<tr class="separator:a1db595de4e0815f91d5aba9765b942de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562d500b4202fbc2afb7123571ac6d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a562d500b4202fbc2afb7123571ac6d60">operator*</a> (const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a562d500b4202fbc2afb7123571ac6d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise multiplication of two sparse matrices.  <a href="classslt_1_1SparseCOOMatrix.html#a562d500b4202fbc2afb7123571ac6d60">More...</a><br /></td></tr>
<tr class="separator:a562d500b4202fbc2afb7123571ac6d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f0e3fdab670152566ce8353a9c42fa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#aa8f0e3fdab670152566ce8353a9c42fa">rows</a> () const override</td></tr>
<tr class="memdesc:aa8f0e3fdab670152566ce8353a9c42fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the matrix.  <a href="classslt_1_1SparseCOOMatrix.html#aa8f0e3fdab670152566ce8353a9c42fa">More...</a><br /></td></tr>
<tr class="separator:aa8f0e3fdab670152566ce8353a9c42fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccef3397e1eeb5c9a4a1e895ff25866"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a1ccef3397e1eeb5c9a4a1e895ff25866">cols</a> () const override</td></tr>
<tr class="memdesc:a1ccef3397e1eeb5c9a4a1e895ff25866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the matrix.  <a href="classslt_1_1SparseCOOMatrix.html#a1ccef3397e1eeb5c9a4a1e895ff25866">More...</a><br /></td></tr>
<tr class="separator:a1ccef3397e1eeb5c9a4a1e895ff25866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8060856161b5989ab2f30b87d8d5bf71"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71">get</a> (std::size_t r, std::size_t c) const override</td></tr>
<tr class="memdesc:a8060856161b5989ab2f30b87d8d5bf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value at the specified matrix location.  <a href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71">More...</a><br /></td></tr>
<tr class="separator:a8060856161b5989ab2f30b87d8d5bf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532cedb759d6e7e633c4a3ad84f17c69"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classslt_1_1MatrixBase.html">MatrixBase</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a532cedb759d6e7e633c4a3ad84f17c69">clone</a> () const override</td></tr>
<tr class="memdesc:a532cedb759d6e7e633c4a3ad84f17c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a polymorphic deep copy of this matrix.  <a href="classslt_1_1SparseCOOMatrix.html#a532cedb759d6e7e633c4a3ad84f17c69">More...</a><br /></td></tr>
<tr class="separator:a532cedb759d6e7e633c4a3ad84f17c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab948cfcf480803e9469c735807d31d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ab948cfcf480803e9469c735807d31d6e">set</a> (std::size_t r, std::size_t c, T value) override</td></tr>
<tr class="memdesc:ab948cfcf480803e9469c735807d31d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value in the matrix at the given (row, column) index.  <a href="classslt_1_1SparseCOOMatrix.html#ab948cfcf480803e9469c735807d31d6e">More...</a><br /></td></tr>
<tr class="separator:ab948cfcf480803e9469c735807d31d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d1204d80d8b51f20217c5af322a2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a30d1204d80d8b51f20217c5af322a2da">update</a> (std::size_t r, std::size_t c, T value)</td></tr>
<tr class="memdesc:a30d1204d80d8b51f20217c5af322a2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an existing value in the matrix at (row, column).  <a href="classslt_1_1SparseCOOMatrix.html#a30d1204d80d8b51f20217c5af322a2da">More...</a><br /></td></tr>
<tr class="separator:a30d1204d80d8b51f20217c5af322a2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889f1c98e467ceb29a74a1fa3efa6d44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a889f1c98e467ceb29a74a1fa3efa6d44">is_initialized</a> (std::size_t r, std::size_t c) const override</td></tr>
<tr class="memdesc:a889f1c98e467ceb29a74a1fa3efa6d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the element at the specified row and column is initialized (non-zero).  <a href="classslt_1_1SparseCOOMatrix.html#a889f1c98e467ceb29a74a1fa3efa6d44">More...</a><br /></td></tr>
<tr class="separator:a889f1c98e467ceb29a74a1fa3efa6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dd10fb10528bb4abee019204d3fc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64">finalize</a> ()</td></tr>
<tr class="memdesc:af2dd10fb10528bb4abee019204d3fc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the internal COO representation for querying.  <a href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64">More...</a><br /></td></tr>
<tr class="separator:af2dd10fb10528bb4abee019204d3fc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed0440765b5f86cf842ae4b67b46621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a0ed0440765b5f86cf842ae4b67b46621">set_fast</a> () const</td></tr>
<tr class="memdesc:a0ed0440765b5f86cf842ae4b67b46621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is in fast insertion mode.  <a href="classslt_1_1SparseCOOMatrix.html#a0ed0440765b5f86cf842ae4b67b46621">More...</a><br /></td></tr>
<tr class="separator:a0ed0440765b5f86cf842ae4b67b46621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classslt_1_1MatrixBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classslt_1_1MatrixBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classslt_1_1MatrixBase.html">slt::MatrixBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1MatrixBase.html#a3bbb4cd026c2c1da1ba0881c918630b1">~MatrixBase</a> ()=default</td></tr>
<tr class="memdesc:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for safe polymorphic deletion.  <a href="classslt_1_1MatrixBase.html#a3bbb4cd026c2c1da1ba0881c918630b1">More...</a><br /></td></tr>
<tr class="separator:a3bbb4cd026c2c1da1ba0881c918630b1 inherit pub_methods_classslt_1_1MatrixBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3401da28257fbe2af0fcd501b5fe0ea4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a3401da28257fbe2af0fcd501b5fe0ea4">data</a></td></tr>
<tr class="memdesc:a3401da28257fbe2af0fcd501b5fe0ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat row-major storage of matrix elements.  <a href="classslt_1_1SparseCOOMatrix.html#a3401da28257fbe2af0fcd501b5fe0ea4">More...</a><br /></td></tr>
<tr class="separator:a3401da28257fbe2af0fcd501b5fe0ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dc765141e8635009ff85e9f1c1b1f6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a82dc765141e8635009ff85e9f1c1b1f6">rows_</a> = 0</td></tr>
<tr class="memdesc:a82dc765141e8635009ff85e9f1c1b1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Matrix rows.  <a href="classslt_1_1SparseCOOMatrix.html#a82dc765141e8635009ff85e9f1c1b1f6">More...</a><br /></td></tr>
<tr class="separator:a82dc765141e8635009ff85e9f1c1b1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5ba6c9996a3b093529cc4f135079d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#a1d5ba6c9996a3b093529cc4f135079d5">cols_</a> = 0</td></tr>
<tr class="memdesc:a1d5ba6c9996a3b093529cc4f135079d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Matrix columns.  <a href="classslt_1_1SparseCOOMatrix.html#a1d5ba6c9996a3b093529cc4f135079d5">More...</a><br /></td></tr>
<tr class="separator:a1d5ba6c9996a3b093529cc4f135079d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec54f3c4530a3c503131a2b37b19c5a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#aec54f3c4530a3c503131a2b37b19c5a4">row</a></td></tr>
<tr class="memdesc:aec54f3c4530a3c503131a2b37b19c5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing row indices.  <a href="classslt_1_1SparseCOOMatrix.html#aec54f3c4530a3c503131a2b37b19c5a4">More...</a><br /></td></tr>
<tr class="separator:aec54f3c4530a3c503131a2b37b19c5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ea84ab29c1ac833854de16386b60fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ac9ea84ab29c1ac833854de16386b60fb">col</a></td></tr>
<tr class="memdesc:ac9ea84ab29c1ac833854de16386b60fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing column indices.  <a href="classslt_1_1SparseCOOMatrix.html#ac9ea84ab29c1ac833854de16386b60fb">More...</a><br /></td></tr>
<tr class="separator:ac9ea84ab29c1ac833854de16386b60fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab890c296bec63f265a2c1cd167a88eec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslt_1_1SparseCOOMatrix.html#ab890c296bec63f265a2c1cd167a88eec">fast_set</a> = true</td></tr>
<tr class="memdesc:ab890c296bec63f265a2c1cd167a88eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if vectors are optimized for insertation, false if optimized for retrieval  <a href="classslt_1_1SparseCOOMatrix.html#ab890c296bec63f265a2c1cd167a88eec">More...</a><br /></td></tr>
<tr class="separator:ab890c296bec63f265a2c1cd167a88eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class slt::SparseCOOMatrix&lt; T &gt;</h3>

<p>A sparse matrix implementation using the Coordinate List (COO) format. </p>
<p>This class stores non-zero elements of a matrix using three parallel vectors: one for row indices, one for column indices, and one for the data values. It supports two operational modes:</p>
<ul>
<li>**Fast Insertion Mode (<code>fast_set = true</code>)**: Allows fast, unordered appends of (row, column, value) triplets. This mode is ideal for incremental construction of the matrix but requires a call to <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64" title="Finalizes the internal COO representation for querying.">finalize()</a></code> before performing reliable access or update operations.</li>
<li>**Finalized Mode (<code>fast_set = false</code>)**: Ensures the internal storage is sorted lexicographically by (row, column). Enables efficient binary search for <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71" title="Retrieves the value at the specified matrix location.">get()</a></code>, <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#a30d1204d80d8b51f20217c5af322a2da" title="Updates an existing value in the matrix at (row, column).">update()</a></code>, and <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#a889f1c98e467ceb29a74a1fa3efa6d44" title="Checks if the element at the specified row and column is initialized (non-zero).">is_initialized()</a></code> methods.</li>
</ul>
<p>The class conforms to a polymorphic base class <code><a class="el" href="classslt_1_1MatrixBase.html" title="Abstract base class for matrix types.">MatrixBase</a>&lt;T&gt;</code>, allowing it to be used in a generic matrix interface with other matrix types such as dense or CSR.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric type stored in the matrix (must be <code>float</code> or <code>double</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line">SparseCOOMatrix&lt;float&gt; mat(3, 3);</div>
<div class="line">mat.set(0, 0, 1.0f);</div>
<div class="line">mat.set(2, 1, 5.0f);</div>
<div class="line">mat.finalize();</div>
<div class="line"><span class="keywordtype">float</span> value = mat.get(2, 1);  <span class="comment">// returns 5.0</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#_a0">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdf817cb3a1cfdd63825edd72b7af332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf817cb3a1cfdd63825edd72b7af332">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fastInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty sparse COO matrix with given dimensions. </p>
<p>Initializes internal storage with a small reserved capacity and sets the fast insertion mode according to <code>fastInsert</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Number of rows in the matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns in the matrix. </td></tr>
    <tr><td class="paramname">fastInsert</td><td>If true, enables fast insertion mode (default: true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a60">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0556e77c2ab536d1e9f98924ebc00325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0556e77c2ab536d1e9f98924ebc00325">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fastInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sparse COO matrix from a 2D std::vector. </p>
<p>Non-zero elements from the input vector are inserted into the sparse matrix. If <code>fastInsert</code> is true, elements are inserted in append mode and <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64" title="Finalizes the internal COO representation for querying.">finalize()</a></code> must be called manually before sorted access (e.g., <a class="el" href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71" title="Retrieves the value at the specified matrix location.">get()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A 2D vector representing the matrix. </td></tr>
    <tr><td class="paramname">fastInsert</td><td>Enables fast insertion mode if true (default: true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if rows have inconsistent lengths. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1823148f7dd13b5e31c55c218d31f8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1823148f7dd13b5e31c55c218d31f8ab">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;std::size_t Rows, std::size_t Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, Cols &gt;, Rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fastInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sparse COO matrix from a fixed-size std::array. </p>
<p>Non-zero values in the 2D array are inserted into the matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>Number of rows in the static array. </td></tr>
    <tr><td class="paramname">Cols</td><td>Number of columns in the static array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Fixed-size array of values to initialize the matrix. </td></tr>
    <tr><td class="paramname">fastInsert</td><td>Enables fast insertion mode if true (default: true). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdf93130e5698de91ab00c3640497e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf93130e5698de91ab00c3640497e7c">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>initList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fastInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sparse COO matrix from a nested initializer list. </p>
<p>This allows convenient initialization using brace-enclosed lists. Only non-zero elements are stored. Rows must be of consistent length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initList</td><td>Nested initializer list (e.g., <code>{{1, 0}, {0, 2}}</code>). </td></tr>
    <tr><td class="paramname">fastInsert</td><td>Enables fast insertion mode if true (default: true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if inner lists have inconsistent sizes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae770b21eed338ffb9befcfdd9980018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae770b21eed338ffb9befcfdd9980018e">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>flat_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fastInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sparse COO matrix from a flat vector in row-major order. </p>
<p>Only non-zero values are inserted into the matrix. The resulting matrix will include only the explicitly stored entries. If <code>fastInsert</code> is true, entries are added in append mode and require <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64" title="Finalizes the internal COO representation for querying.">finalize()</a></code> before sorted access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flat_data</td><td>A 1D vector in row-major order. </td></tr>
    <tr><td class="paramname">r</td><td>Number of rows in the matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Number of columns in the matrix. </td></tr>
    <tr><td class="paramname">fastInsert</td><td>Enables fast insertion mode if true (default: true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the size of flat_data != r * c. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca17fa945fb3d058e784e9c448f257f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca17fa945fb3d058e784e9c448f257f0">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>. </p>
<p>Constructs a new <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a> as a deep copy of the provided matrix. All internal data structures (values, row/column indices, flags) are duplicated, preserving the state of the original matrix while ensuring full independence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a> instance to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This performs a deep copy. Changes to the new matrix will not affect the original. </dd></dl>

</div>
</div>
<a id="a6c524c58afeb267a0e3cd0bddc2b9be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c524c58afeb267a0e3cd0bddc2b9be3">&#9670;&nbsp;</a></span>SparseCOOMatrix() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::<a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>. </p>
<p>Constructs a new sparse matrix by transferring ownership of data from another matrix. This constructor performs a shallow move of internal vectors and resets the source matrix to a default, empty state.</p>
<p>This is more efficient than the copy constructor, as it avoids deep copying of data and instead reuses existing memory buffers. After the move, the source matrix is left in a valid but unspecified state (typically empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to move from. After the operation, <code>other</code> is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>fast_set</code> flag is also transferred and reset in the source. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a532cedb759d6e7e633c4a3ad84f17c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532cedb759d6e7e633c4a3ad84f17c69">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classslt_1_1MatrixBase.html">MatrixBase</a>&lt;T&gt; &gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a polymorphic deep copy of this matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to the copied matrix. </dd></dl>

<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a10ca9a5de506b53de715596507c77321">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a71">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0d82d6bb156ed5dbb372bb7c8155b7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d82d6bb156ed5dbb372bb7c8155b7d5">&#9670;&nbsp;</a></span>col_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::col_index </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column index of the i-th non-zero element. </p>
<p>This accessor returns the column position associated with the i-th stored non-zero value in the sparse COO matrix. Bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the non-zero element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column index corresponding to the i-th element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is outside the valid range.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 0.0f},</div>
<div class="line">    {0.0f, 2.0f}</div>
<div class="line">});</div>
<div class="line">std::size_t c = mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#a0d82d6bb156ed5dbb372bb7c8155b7d5">col_index</a>(1);  <span class="comment">// Returns column index of second non-zero</span></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a></div><div class="ttdoc">A sparse matrix implementation using the Coordinate List (COO) format.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2254</div></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_a0d82d6bb156ed5dbb372bb7c8155b7d5"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#a0d82d6bb156ed5dbb372bb7c8155b7d5">slt::SparseCOOMatrix::col_index</a></div><div class="ttdeci">std::size_t col_index(std::size_t i) const</div><div class="ttdoc">Returns the column index of the i-th non-zero element.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2358</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a58">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ccef3397e1eeb5c9a4a1e895ff25866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccef3397e1eeb5c9a4a1e895ff25866">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the matrix. </p>
<p>This function returns the total number of columns allocated for the matrix, which includes all column indices regardless of whether they contain non-zero entries.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of columns.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat(3, 4);</div>
<div class="line">std::size_t c = mat.cols();  <span class="comment">// Returns 4</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#acee40c97e44474a9619b808b63d1868b">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a70">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="af2dd10fb10528bb4abee019204d3fc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dd10fb10528bb4abee019204d3fc64">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes the internal COO representation for querying. </p>
<p>This method is required after using fast insertion mode (<code>fast_set = true</code>) to sort the (row, column, value) triplets into lexicographic order. Once finalized, efficient binary search and reliable get/update/is_initialized operations are enabled.</p>
<p>This method performs a stable sort and disables fast insertion mode. </p>

</div>
</div>
<a id="a8060856161b5989ab2f30b87d8d5bf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8060856161b5989ab2f30b87d8d5bf71">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value at the specified matrix location. </p>
<p>Returns the value stored at the given row and column index in the sparse matrix. If the element has not been explicitly initialized (i.e., not stored in the COO format), the function throws a runtime exception.</p>
<p>The function uses a linear search if the matrix was constructed with <code>fast_set == true</code>, and a binary search if the entries are sorted (<code>fast_set == false</code>), allowing efficient retrieval in both cases depending on construction strategy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index of the target element. </td></tr>
    <tr><td class="paramname">c</td><td>Column index of the target element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified matrix location.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the provided row or column index is outside the matrix bounds. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If the specified element is uninitialized and thus not stored.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 0.0f},</div>
<div class="line">    {0.0f, 3.0f}</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">float</span> val = mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71">get</a>(1, 1);  <span class="comment">// Returns 3.0f</span></div>
<div class="line"><span class="keywordtype">float</span> missing = mat.get(0, 1);  <span class="comment">// Throws runtime_error</span></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_a8060856161b5989ab2f30b87d8d5bf71"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#a8060856161b5989ab2f30b87d8d5bf71">slt::SparseCOOMatrix::get</a></div><div class="ttdeci">T get(std::size_t r, std::size_t c) const override</div><div class="ttdoc">Retrieves the value at the specified matrix location.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2912</div></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a5fe460dc2d97ee440c32635d5f3192fc">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a63">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a889f1c98e467ceb29a74a1fa3efa6d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889f1c98e467ceb29a74a1fa3efa6d44">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::is_initialized </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the element at the specified row and column is initialized (non-zero). </p>
<p>This function determines whether a value has been explicitly assigned to the given row and column in the sparse matrix. It supports two modes:</p>
<ul>
<li>**Fast set mode (<code>fast_set = true</code>)**: Performs a linear search through the unsorted COO entries.</li>
<li>**Sorted mode (<code>fast_set = false</code>)**: Performs a binary search assuming the entries are sorted by row-major order (i.e., row first, then column).</li>
</ul>
<p>This is useful for determining if a matrix entry is actively stored (i.e., not a structural zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index of the element. </td></tr>
    <tr><td class="paramname">c</td><td>Column index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element is explicitly initialized (non-zero); otherwise <code>false</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the given row or column index is outside the matrix bounds.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 0.0f},</div>
<div class="line">    {0.0f, 2.0f}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> found = mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#a889f1c98e467ceb29a74a1fa3efa6d44">is_initialized</a>(1, 1);  <span class="comment">// Returns true</span></div>
<div class="line"><span class="keywordtype">bool</span> empty = mat.is_initialized(0, 1);  <span class="comment">// Returns false</span></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_a889f1c98e467ceb29a74a1fa3efa6d44"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#a889f1c98e467ceb29a74a1fa3efa6d44">slt::SparseCOOMatrix::is_initialized</a></div><div class="ttdeci">bool is_initialized(std::size_t r, std::size_t c) const override</div><div class="ttdoc">Checks if the element at the specified row and column is initialized (non-zero).</div><div class="ttdef"><b>Definition:</b> matrix.hpp:3073</div></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a069249b28295c9776df81efed6076589">slt::MatrixBase&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a5daf5e8c69cd9f68f468cd41e06cd45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5daf5e8c69cd9f68f468cd41e06cd45e">&#9670;&nbsp;</a></span>nonzero_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::nonzero_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of explicitly stored non-zero elements. </p>
<p>This function returns the number of entries stored in the sparse COO matrix, which corresponds to the number of non-zero elements it currently tracks. Unlike a dense matrix, uninitialized values are implicitly zero and are not stored.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of stored non-zero elements.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8hpp.html">matrix.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">        {1.0f, 0.0f},</div>
<div class="line">        {0.0f, 2.0f}</div>
<div class="line">    });</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Non-zero elements: &quot;</span> &lt;&lt; mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#a5daf5e8c69cd9f68f468cd41e06cd45e">nonzero_count</a>() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_a5daf5e8c69cd9f68f468cd41e06cd45e"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#a5daf5e8c69cd9f68f468cd41e06cd45e">slt::SparseCOOMatrix::nonzero_count</a></div><div class="ttdeci">std::size_t nonzero_count() const override</div><div class="ttdoc">Returns the number of explicitly stored non-zero elements.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2313</div></div>
<div class="ttc" id="amatrix_8hpp_html"><div class="ttname"><a href="matrix_8hpp.html">matrix.hpp</a></div></div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">Non-zero elements: 2</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a56cfa6060fc56b9225e26f0206a77519">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a56">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="abb078adcd4c95de5d7bddbe438a06316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb078adcd4c95de5d7bddbe438a06316">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses a matrix element (read-only). </p>
<p>Retrieves the value at the specified row and column. If the element has not been set, throws an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index (zero-based). </td></tr>
    <tr><td class="paramname">c</td><td>Column index (zero-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the given position. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the element is uninitialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a62">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a562d500b4202fbc2afb7123571ac6d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562d500b4202fbc2afb7123571ac6d60">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs element-wise multiplication of two sparse matrices. </p>
<p>Multiplies corresponding non-zero elements where both matrices store a value. Returns a new <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a> containing only the overlapping non-zero positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a> to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a> containing the element-wise product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the matrix dimensions do not match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a68">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a92b8c482627448d29d112af92da1afb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b8c482627448d29d112af92da1afb8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt;T&gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a66">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="add1bd1320cb996c904f3f56d6897c9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1bd1320cb996c904f3f56d6897c9cf">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a869a28d52e8cf7658dc8cc87a9bfcc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869a28d52e8cf7658dc8cc87a9bfcc6d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1DenseMatrix.html">DenseMatrix</a>&lt;T&gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a67">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1db595de4e0815f91d5aba9765b942de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db595de4e0815f91d5aba9765b942de">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a> <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8066b8bab1b1db44570b043591547447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8066b8bab1b1db44570b043591547447">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt;T&gt;&amp; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy assignment operator. </p>
<p>Copies all metadata and contents (rows, cols, data, etc.) from another <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>. The two matrices become fully independent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source matrix to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this matrix. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a65">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7851db1ffece701e976625710f88aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7851db1ffece701e976625710f88aaf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt;T&gt;&amp; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Transfers resources from another <a class="el" href="classslt_1_1SparseCOOMatrix.html" title="A sparse matrix implementation using the Coordinate List (COO) format.">SparseCOOMatrix</a>, leaving the source in a valid but empty state. Enables efficient transfer of large matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source matrix to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this matrix. </dd></dl>

</div>
</div>
<a id="a1dc02d00cac074d3771223b358de6152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc02d00cac074d3771223b358de6152">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslt_1_1SparseCOOMatrix.html">SparseCOOMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a64">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a26f9d4289054f90dc5248edee3385f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f9d4289054f90dc5248edee3385f2d">&#9670;&nbsp;</a></span>row_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::row_index </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the row index of the i-th non-zero element. </p>
<p>This accessor returns the row position associated with the i-th stored non-zero value in the sparse COO matrix. Bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the non-zero element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row index corresponding to the i-th element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is outside the valid range.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 0.0f},</div>
<div class="line">    {0.0f, 2.0f}</div>
<div class="line">});</div>
<div class="line">std::size_t r = mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#a26f9d4289054f90dc5248edee3385f2d">row_index</a>(1);  <span class="comment">// Returns row index of second non-zero</span></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_a26f9d4289054f90dc5248edee3385f2d"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#a26f9d4289054f90dc5248edee3385f2d">slt::SparseCOOMatrix::row_index</a></div><div class="ttdeci">std::size_t row_index(std::size_t i) const</div><div class="ttdoc">Returns the row index of the i-th non-zero element.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2334</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a57">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa8f0e3fdab670152566ce8353a9c42fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0e3fdab670152566ce8353a9c42fa">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the matrix. </p>
<p>This function provides the total number of rows defined in the matrix, regardless of how many entries are explicitly stored or initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of rows.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat(3, 4);</div>
<div class="line">std::size_t r = mat.rows();  <span class="comment">// Returns 3</span></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#af5247088bf3743574e25430da458ff46">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a69">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab948cfcf480803e9469c735807d31d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab948cfcf480803e9469c735807d31d6e">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value in the matrix at the given (row, column) index. </p>
<p>If <code>fast_set</code> is true, the value is appended without checking for duplicates or maintaining order (O(1) insertion). This is efficient for bulk construction but requires calling <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64" title="Finalizes the internal COO representation for querying.">finalize()</a></code> before reliable queries.</p>
<p>If <code>fast_set</code> is false, the method performs a binary search and inserts the value at the correct sorted position. Duplicate insertions will throw.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index of the element. </td></tr>
    <tr><td class="paramname">c</td><td>Column index of the element. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful insertion. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if indices are invalid. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if value already exists and <code>fast_set</code> is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a2925cbdba8ec46c258f8d8e1fb1b730d">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a61">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0ed0440765b5f86cf842ae4b67b46621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed0440765b5f86cf842ae4b67b46621">&#9670;&nbsp;</a></span>set_fast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::set_fast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is in fast insertion mode. </p>
<p>This method reports the current status of the <code>fast_set</code> flag. When true, the matrix is in fast insertion mode—entries can be appended quickly without maintaining order or checking for duplicates. When false, the matrix is in finalized mode and supports efficient retrieval operations (e.g., via binary search).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the matrix is in fast insertion mode; false if finalized. </dd></dl>

</div>
</div>
<a id="adc0211d7a6ffae48b7e796d5f9dacd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0211d7a6ffae48b7e796d5f9dacd15">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total size of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows multiplied by the number of columns, 0 if not initialized </dd></dl>

<p>Implements <a class="el" href="classslt_1_1MatrixBase.html#a9240f5b4144ddf0e284e44b61b10fa49">slt::MatrixBase&lt; T &gt;</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a55">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a30d1204d80d8b51f20217c5af322a2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d1204d80d8b51f20217c5af322a2da">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::update </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates an existing value in the matrix at (row, column). </p>
<p>Performs a binary search for the target index. If the element is found, the value is updated in-place. If the element does not exist, an exception is thrown (you must call <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#ab948cfcf480803e9469c735807d31d6e" title="Sets a value in the matrix at the given (row, column) index.">set()</a></code> first).</p>
<p>This method requires <code><a class="el" href="classslt_1_1SparseCOOMatrix.html#af2dd10fb10528bb4abee019204d3fc64" title="Finalizes the internal COO representation for querying.">finalize()</a></code> to have been called if the matrix was initially constructed in fast insertion mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Row index of the element. </td></tr>
    <tr><td class="paramname">c</td><td>Column index of the element. </td></tr>
    <tr><td class="paramname">value</td><td>New value to assign to the existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful update. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if indices are invalid. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the element is not already set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a72">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae41de6aa5a303e7997a29c1d4422477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41de6aa5a303e7997a29c1d4422477b">&#9670;&nbsp;</a></span>value_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::value_index </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the i-th non-zero element. </p>
<p>This accessor returns the stored numerical value of the i-th non-zero entry in the sparse COO matrix. Bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the non-zero element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the i-th non-zero element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the index is outside the valid range.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix&lt;float&gt;</a> mat({</div>
<div class="line">    {1.0f, 0.0f},</div>
<div class="line">    {0.0f, 2.0f}</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">float</span> v = mat.<a class="code" href="classslt_1_1SparseCOOMatrix.html#ae41de6aa5a303e7997a29c1d4422477b">value_index</a>(1);  <span class="comment">// Returns 2.0f</span></div>
<div class="ttc" id="aclassslt_1_1SparseCOOMatrix_html_ae41de6aa5a303e7997a29c1d4422477b"><div class="ttname"><a href="classslt_1_1SparseCOOMatrix.html#ae41de6aa5a303e7997a29c1d4422477b">slt::SparseCOOMatrix::value_index</a></div><div class="ttdeci">T value_index(std::size_t i) const</div><div class="ttdoc">Returns the value of the i-th non-zero element.</div><div class="ttdef"><b>Definition:</b> matrix.hpp:2382</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a59">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac9ea84ab29c1ac833854de16386b60fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ea84ab29c1ac833854de16386b60fb">&#9670;&nbsp;</a></span>col</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::col</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector containing column indices. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a52">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1d5ba6c9996a3b093529cc4f135079d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5ba6c9996a3b093529cc4f135079d5">&#9670;&nbsp;</a></span>cols_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::cols_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of Matrix columns. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a50">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3401da28257fbe2af0fcd501b5fe0ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3401da28257fbe2af0fcd501b5fe0ea4">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flat row-major storage of matrix elements. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a48">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab890c296bec63f265a2c1cd167a88eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab890c296bec63f265a2c1cd167a88eec">&#9670;&nbsp;</a></span>fast_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::fast_set = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if vectors are optimized for insertation, false if optimized for retrieval </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a53">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="aec54f3c4530a3c503131a2b37b19c5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec54f3c4530a3c503131a2b37b19c5a4">&#9670;&nbsp;</a></span>row</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector containing row indices. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a51">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a82dc765141e8635009ff85e9f1c1b1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dc765141e8635009ff85e9f1c1b1f6">&#9670;&nbsp;</a></span>rows_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classslt_1_1SparseCOOMatrix.html">slt::SparseCOOMatrix</a>&lt; T &gt;::rows_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of Matrix rows. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2jonwebb_2Code_Dev_2C_09_09_2csalt_09_09_2csalt_09_09_2include_2matrix_8hpp-example.html#a49">/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/matrix.hpp</a>.</dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jonwebb/Code_Dev/C++/csalt++/csalt++/include/<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
